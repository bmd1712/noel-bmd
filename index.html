<!DOCTYPE html>
<html lang="VN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xmas Luxury - Interactive Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; padding-top: 40px; box-sizing: border-box;
        }

        h1 { 
            color: #fceea7; font-size: 50px; margin: 0; font-weight: 400; letter-spacing: 8px; 
            text-shadow: 0 0 30px rgba(252, 238, 167, 0.8);
            background: linear-gradient(to bottom, #fff, #d4af37);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', serif;
        }

        .hint-wrapper { margin-top: 20px; pointer-events: auto; text-align: center; }
        .hint-text { 
            color: #d4af37; font-size: 11px; letter-spacing: 2px; text-transform: uppercase;
            background: rgba(0,0,0,0.4); padding: 8px 20px; border: 1px solid rgba(212, 175, 55, 0.3);
            backdrop-filter: blur(5px);
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.8s;
        }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div style="color:#d4af37; margin-top:15px; letter-spacing:3px;">ĐANG TẢI...</div>
</div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <h1>MERRY CHRISTMAS</h1>
    <div class="hint-wrapper">
        <div class="hint-text">Click vào ảnh để xem | Click nền để tụ cây | Giữ chuột để xoay</div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const CONFIG = {
        treeHeight: 25,
        treeRadius: 9,
        particleCount: 2000,
        glowColor: 0xffe69a,
        accentColor: 0xff3300
    };

    // Đã bỏ phần upload - Chỉ dùng ảnh trong folder images
    const LOCAL_IMAGES = ['images/1.jpg', 'images/2.jpg', 'images/3.jpg', 'images/4.jpg', 'images/5.jpg', 'images/6.jpg', 'images/7.jpg'];

    let scene, camera, renderer, composer, mainGroup, photoGroup;
    let particles = [], clock = new THREE.Clock();
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let isDragging = false, prevMouse = {x:0, y:0};
    let state = { mode: 'TREE', focusTarget: null, rotation: {x:0, y:0} };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 60);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.0; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        mainGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        scene.add(mainGroup);
        mainGroup.add(photoGroup);

        createLuxuryParticles();
        setupPostProcessing();
        setupEvents();
        loadPhotos();

        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 800);
        }, 1500);

        animate();
    }

    function createLuxuryParticles() {
        const geometries = [new THREE.SphereGeometry(0.12, 8, 8), new THREE.OctahedronGeometry(0.2)];
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.glowColor, emissive: CONFIG.glowColor, emissiveIntensity: 1.5, metalness: 1, roughness: 0 
        });
        const redMat = new THREE.MeshStandardMaterial({ color: CONFIG.accentColor, emissive: CONFIG.accentColor, emissiveIntensity: 1 });

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const mesh = new THREE.Mesh(geometries[Math.floor(Math.random()*geometries.length)], Math.random() > 0.9 ? redMat : goldMat);
            const p = {
                mesh: mesh,
                posScatter: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120),
                posTree: calculateTreePos(),
            };
            mainGroup.add(mesh);
            particles.push(p);
        }
        
        const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), goldMat);
        star.position.set(0, CONFIG.treeHeight/2 + 1, 0);
        mainGroup.add(star);
    }

    function calculateTreePos() {
        const t = Math.pow(Math.random(), 0.85);
        const y = (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
        const rMax = Math.max(CONFIG.treeRadius * (1.0 - t), 0.5);
        const angle = t * 45 + Math.random() * Math.PI * 2;
        const r = rMax * (0.9 + Math.random() * 0.2);
        return new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    }

    function loadPhotos() {
        const loader = new THREE.TextureLoader();
        LOCAL_IMAGES.forEach(url => {
            loader.load(url, tex => {
                tex.colorSpace = THREE.SRGBColorSpace;
                
                // TÍNH TOÁN ASPECT RATIO ĐỂ KHÔNG BỊ MÉO
                const aspect = tex.image.width / tex.image.height;
                const baseHeight = 1.8;
                const baseWidth = baseHeight * aspect;

                const g = new THREE.Group();
                // Khung ảnh màu vàng champagne
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(baseWidth + 0.15, baseHeight + 0.15, 0.08), 
                    new THREE.MeshStandardMaterial({color:0xd4af37, metalness:0.8, roughness:0.2})
                );
                
                // Ảnh sử dụng vật liệu Basic để tránh bị Bloom quá mức làm cháy màu
                const pic = new THREE.Mesh(
                    new THREE.PlaneGeometry(baseWidth, baseHeight), 
                    new THREE.MeshBasicMaterial({map:tex, side: THREE.DoubleSide})
                );
                pic.position.z = 0.05;
                g.add(frame, pic);
                
                const p = {
                    mesh: g,
                    posScatter: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                    posTree: calculateTreePos().multiplyScalar(1.2),
                    isPhoto: true
                };
                photoGroup.add(g);
                particles.push(p);
            });
        });
    }

    function setupPostProcessing() {
        const renderPass = new RenderPass(scene, camera);
        // Ngưỡng Threshold cao (0.8) để chỉ những hạt phát sáng mới Bloom, còn ảnh thì không
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.8);
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
    }

    function setupEvents() {
        window.addEventListener('mousedown', e => { isDragging = true; prevMouse = {x: e.clientX, y: e.clientY}; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if(isDragging) {
                state.rotation.y += (e.clientX - prevMouse.x) * 0.005;
                state.rotation.x += (e.clientY - prevMouse.y) * 0.005;
                prevMouse = {x: e.clientX, y: e.clientY};
            }
        });

        window.addEventListener('click', e => {
            if(isDragging && Math.abs(e.clientX - prevMouse.x) > 5) return;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(photoGroup.children, true);

            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent !== photoGroup) obj = obj.parent;
                
                if(state.focusTarget === obj) {
                    state.focusTarget = null;
                    state.mode = 'TREE'; // Thu cây lại
                } else {
                    state.focusTarget = obj;
                    state.mode = 'SCATTER'; // "NỔ" cây khi xem ảnh
                }
            } else {
                state.mode = (state.mode === 'SCATTER') ? 'TREE' : 'SCATTER';
                state.focusTarget = null;
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        if(!isDragging && state.mode === 'TREE') state.rotation.y += 0.4 * dt;
        mainGroup.rotation.y = state.rotation.y;
        mainGroup.rotation.x = state.rotation.x;

        particles.forEach(p => {
            let target;
            if (state.focusTarget && p.mesh === state.focusTarget) {
                // Đưa ảnh ra trước mặt camera, khoảng cách 20 đơn vị
                const forward = new THREE.Vector3(0, 0, 20).applyQuaternion(camera.quaternion);
                target = new THREE.Vector3().copy(camera.position).sub(forward);
                p.mesh.lookAt(camera.position);
                p.mesh.scale.lerp(new THREE.Vector3(4, 4, 4), 6 * dt);
            } else {
                target = (state.mode === 'TREE') ? p.posTree : p.posScatter;
                p.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 5 * dt);
                if(p.isPhoto) {
                    p.mesh.rotation.y += dt * 0.5;
                    p.mesh.rotation.x = Math.sin(elapsed + p.mesh.id) * 0.2;
                }
            }
            p.mesh.position.lerp(target, 2.5 * dt);
            
            if(!p.isPhoto) {
                p.mesh.material.emissiveIntensity = 1 + Math.sin(elapsed * 4 + p.mesh.id) * 0.6;
            }
        });

        composer.render();
    }

    init();
</script>
</body>
</html>