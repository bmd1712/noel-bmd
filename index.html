<!DOCTYPE html>
<html lang="VN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xmas Luxury - Quick View</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; padding-top: 40px; box-sizing: border-box;
        }
        h1 { 
            color: #fceea7; font-size: 40px; margin: 0; font-weight: 400; letter-spacing: 6px; 
            text-shadow: 0 0 30px rgba(252, 238, 167, 0.8);
            background: linear-gradient(to bottom, #fff, #d4af37);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', serif;
        }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.8s;
        }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div style="color:#d4af37; margin-top:15px; letter-spacing:3px;">ĐANG TẢI...</div>
</div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <h1>MERRY CHRISTMAS</h1>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const CONFIG = {
        treeHeight: 25,
        treeRadius: 9,
        particleCount: 2000,
        glowColor: 0xffe69a,
        accentColor: 0xff3300
    };

    const LOCAL_IMAGES = ['images2/1.jpg', 'images2/2.jpg', 'images2/3.jpg', 'images2/4.jpg', 'images2/5.jpg', 'images2/6.jpg', 'images2/7.jpg', 'images2/8.jpg', 'images2/9.jpg', 'images2/10.jpg', 'images2/11.jpg', 'images2/12.jpg'];

    let scene, camera, renderer, composer, mainGroup, photoGroup;
    let particles = [], clock = new THREE.Clock();
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    
    let isDragging = false;
    let mouseDownTime = 0;
    let startPos = { x: 0, y: 0 };
    let state = { mode: 'TREE', focusTarget: null, rotation: {x:0, y:0} };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 60);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.0; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        mainGroup = new THREE.Group();
        photoGroup = new THREE.Group();
        scene.add(mainGroup);
        mainGroup.add(photoGroup);

        createLuxuryParticles();
        setupPostProcessing();
        setupEvents();
        loadPhotos();

        setTimeout(() => {
            const loader = document.getElementById('loader');
            if(loader) {
                loader.style.opacity = 0;
                setTimeout(() => loader.remove(), 800);
            }
        }, 1500);

        animate();
    }

    function createLuxuryParticles() {
        const geometries = [new THREE.SphereGeometry(0.12, 8, 8), new THREE.OctahedronGeometry(0.2)];
        const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.glowColor, emissive: CONFIG.glowColor, emissiveIntensity: 1.5, metalness: 1, roughness: 0 });
        const redMat = new THREE.MeshStandardMaterial({ color: CONFIG.accentColor, emissive: CONFIG.accentColor, emissiveIntensity: 1 });

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const mesh = new THREE.Mesh(geometries[Math.floor(Math.random()*geometries.length)], Math.random() > 0.9 ? redMat : goldMat);
            const p = {
                mesh: mesh,
                posScatter: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120),
                posTree: calculateTreePos(),
                isPhoto: false
            };
            mainGroup.add(mesh);
            particles.push(p);
        }
        
        const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), goldMat);
        star.position.set(0, CONFIG.treeHeight/2 + 1, 0);
        mainGroup.add(star);
    }

    function calculateTreePos() {
        const t = Math.pow(Math.random(), 0.85);
        const y = (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
        const rMax = Math.max(CONFIG.treeRadius * (1.0 - t), 0.5);
        const angle = t * 45 + Math.random() * Math.PI * 2;
        const r = rMax * (0.9 + Math.random() * 0.2);
        return new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    }

    function loadPhotos() {
        const loader = new THREE.TextureLoader();
        LOCAL_IMAGES.forEach(url => {
            loader.load(url, tex => {
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;

                const aspect = tex.image.width / tex.image.height;
                
                // --- KÍCH THƯỚC BAN ĐẦU CỦA ẢNH ---
                const baseHeight = 3.0; 
                const baseWidth = baseHeight * aspect;

                const g = new THREE.Group();
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(baseWidth + 0.15, baseHeight + 0.15, 0.08), 
                    new THREE.MeshStandardMaterial({color:0xd4af37, metalness:0.8, roughness:0.2})
                );
                
                const pic = new THREE.Mesh(
                    new THREE.PlaneGeometry(baseWidth, baseHeight), 
                    new THREE.MeshBasicMaterial({map:tex, side: THREE.DoubleSide})
                );
                pic.position.z = 0.05;
                g.add(frame, pic);
                
                const p = {
                    mesh: g,
                    posScatter: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                    posTree: calculateTreePos().multiplyScalar(1.2),
                    isPhoto: true
                };
                photoGroup.add(g);
                particles.push(p);
            });
        });
    }

    function setupPostProcessing() {
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
    }

    // --- LOGIC CLICK HIỆN ẢNH (ĐÃ CẬP NHẬT) ---
    function handleInteraction() {
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(photoGroup.children, true);

        if (hits.length > 0) {
            // Nếu click trúng ảnh -> Hiện ảnh ra trước
            let obj = hits[0].object;
            while(obj.parent !== photoGroup) obj = obj.parent;
            
            if (state.focusTarget === obj) {
                // Nếu đang xem ảnh này mà click tiếp thì tắt nó đi
                state.focusTarget = null;
                state.mode = 'TREE';
            } else {
                // Hiện ảnh mới
                state.focusTarget = obj;
                state.mode = 'SCATTER';
            }
        } else {
            // Click ra ngoài -> Đổi trạng thái hoặc tắt ảnh đang xem
            if (state.focusTarget) {
                state.focusTarget = null;
                state.mode = 'TREE';
            } else {
                state.mode = (state.mode === 'SCATTER') ? 'TREE' : 'SCATTER';
            }
        }
    }

    function setupEvents() {
        const getPos = (e) => {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        };

        const onStart = (e) => {
            isDragging = true;
            mouseDownTime = Date.now();
            const pos = getPos(e);
            startPos = { x: pos.x, y: pos.y };
            mouse.x = (pos.x / window.innerWidth) * 2 - 1;
            mouse.y = -(pos.y / window.innerHeight) * 2 + 1;
        };

        const onMove = (e) => {
            const pos = getPos(e);
            mouse.x = (pos.x / window.innerWidth) * 2 - 1;
            mouse.y = -(pos.y / window.innerHeight) * 2 + 1;

            if (isDragging) {
                state.rotation.y += (pos.x - startPos.x) * 0.008;
                state.rotation.x += (pos.y - startPos.y) * 0.008;
                startPos = { x: pos.x, y: pos.y };
            }
        };

        const onEnd = () => {
            const duration = Date.now() - mouseDownTime;
            // Nếu click nhanh (< 250ms) thì mới xử lý hiện ảnh
            if (duration < 250) handleInteraction();
            isDragging = false;
        };

        window.addEventListener('mousedown', onStart);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('touchstart', onStart, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onEnd, { passive: false });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        if(!isDragging && state.mode === 'TREE') state.rotation.y += 0.4 * dt;
        mainGroup.rotation.y = state.rotation.y;
        mainGroup.rotation.x = state.rotation.x;

        particles.forEach(p => {
            let target;
            if (state.focusTarget && p.mesh === state.focusTarget) {
                // --- VỊ TRÍ VÀ KÍCH THƯỚC KHI HIỆN RA TRƯỚC ---
                const forward = new THREE.Vector3(0, 0, 22).applyQuaternion(camera.quaternion);
                target = new THREE.Vector3().copy(camera.position).sub(forward);
                p.mesh.lookAt(camera.position);
                
                // Số 3.5 là kích thước phóng to.
                p.mesh.scale.lerp(new THREE.Vector3(3.5, 3.5, 3.5), 6 * dt);
            } else {
                target = (state.mode === 'TREE') ? p.posTree : p.posScatter;
                p.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 5 * dt);
                if(p.isPhoto) {
                    p.mesh.rotation.y += dt * 0.5;
                    p.mesh.rotation.x = Math.sin(elapsed + p.mesh.id) * 0.2;
                }
            }
            p.mesh.position.lerp(target, 2.5 * dt);
            if(!p.isPhoto) p.mesh.material.emissiveIntensity = 1 + Math.sin(elapsed * 4 + p.mesh.id) * 0.6;
        });
        composer.render();
    }

    init();
</script>
</body>
</html>